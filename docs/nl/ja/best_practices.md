---

copyright:
years: 2021
lastupdated: "2021-02-20"

---

{:new_window: target="blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:child: .link .ulchildlink}
{:childlinks: .ullinks}

# エッジ・ネイティブ開発のベスト・プラクティス
{: #edge_native_practices}

エッジで、つまり、IT データ・センターやクラウド環境といった通常の領域の外部に存在するコンピュート設備で運用するワークロードを作成します。 これは、そういった環境の固有の条件を考慮することが必要であることを意味します。 これはエッジ・ネイティブ・プログラミング・モデルと呼ばれます。

## エッジ・サービス開発のベスト・プラクティス
{: #best_practices}

以下のベスト・プラクティスおよびガイドラインは、{{site.data.keyword.edge_notm}} ({{site.data.keyword.edge_abbr}}) で使用するエッジ・サービスの設計および開発に役立ちます。
{:shortdesc}

エッジでのサービス実行の自動化は、以下の点でクラウド内のサービスの自動化とは異なっています。

* エッジ・ノードの数は大幅に多い可能性があります。
* エッジ・ノードへのネットワークは、信頼できず、速度がもっと遅い可能性があります。 エッジ・ノードはファイアウォールの背後にあることが多く、したがって、クラウドからエッジ・ノードへ接続を開始できないのが一般的です。
* エッジ・ノードはリソースに制約があります。
* エッジでのワークロード運用を促す推進力は、待ち時間を短くできることと、ネットワーク帯域幅を最適化できることです。 そのため、データが生成された場所と関連したワークロード配置が重要な要素になります。 
* 通常、エッジ・ノードはリモート・ロケーションにあり、運用スタッフによってセットアップされることはありません。 エッジ・ノードのセットアップ後に、ノード管理を担当できるスタッフがいない可能性があります。
* エッジ・ノードは、通常、クラウド・サーバーよりも信頼度の低い環境です。

これらの相違により、エッジ・ノードへのソフトウェアのデプロイおよび管理には異なる技法が必要になります。 {{site.data.keyword.edge_abbr}} は、エッジ・ノードの管理用に設計されています。 サービスを作成する場合は、以下のガイドラインに従って、サービスがエッジ・ノードで動作するように設計してください。

## サービス開発のガイドライン
{: #service_guidelines}


* **クラウド・ネイティブなプログラミング・モデル:** エッジ・ネイティブなプログラミング・モデルは、クラウド・ネイティブなプログラミングから以下のような多くの原則を継承します。

  * ワークロードをコンポーネント化およびコンテナー化します – マイクロサービスのセットをパッケージ化して論理的に関連するグループに入れ、それを中心にしてアプリケーションを作成しますが、さまざまなコンテナーを異なる層またはエッジ・ノードのどこで運用すれば最良なのかを認識できるようにグループ分けのバランスを取ります。
  * マイクロサービスへの API の公開により、アプリケーションの他の部分が、依存するサービスを検出できるようにします。
  * マイクロサービス間が疎結合になるように設計することで、マイクロサービスの互いに独立した運用を可能にし、サービス間の類縁性を強要するステートフル仮定 (これは弾力的なスケーリング、フェイルオーバー、および復旧を損ないます) を避けるようにします。
  * DevOps フレームワーク内のアジャイル開発プラクティスと併せて、継続的統合および継続的デプロイメント (CI/CD) を実施します。
  * クラウド・ネイティブなプログラミング・プラクティスに関する詳細情報については、以下の資料を検討してください。
    * [10 KEY ATTRIBUTES OF CLOUD-NATIVE APPLICATIONS](https://thenewstack.io/10-key-attributes-of-cloud-native-applications/)
    * [クラウドネイティブ・プログラミング](https://researcher.watson.ibm.com/researcher/view_group.php?id=9957)
    *	[クラウドネイティブ・アプリケーションとは](https://www.redhat.com/en/topics/cloud-native-apps)

* **サービスの可用性:** ご使用のサービス・コンテナーが他のサービス・コンテナーを必要とし、かつ使用する場合、必要なサービスが存在しない状況でも、ご使用のサービスはそれを許容できなければなりません。 例えば、コンテナーが初めて開始される際に、上方向に移動していく依存関係グラフの末端から開始される場合であっても、一部のサービスが他のサービスよりも早く開始されることがあり得ます。 このような状況では、ご使用のサービス・コンテナーは、依存関係が完全に機能するようになるのを待っている間、再試行する必要があります。 同様に、従属サービス・コンテナーが自動的に更新されると、それは再始動されます。 依存しているサービスで割り込みがあってもそれを常に許容できるようにすることがベスト・プラクティスです。
* **ポータビリティー:** エッジコンピューティングの世界は、 エッジ・デバイス、エッジ・クラスター、およびネットワークまたはメトロ・エッジ・ロケーションを含めて、システムの複数の層にまたがっています。 コンテナー化されたエッジ・ワークロードが最終的に配置される場所は、特定のリソース (センサー・データやアクチュエーターなど) への依存、待ち時間終了要件、および、使用可能なコンピュート能力など、複数の要因の組み合わせによって決まります。 アプリケーションが使用されるコンテキストのニーズに基づいてシステムの異なる層に配置されることを許容できるように、ワークロードを設計する必要があります。
* **コンテナー・オーケストレーション:** 複数層ポータビリティーについての前述の点に加えて、通常、エッジ・デバイスは、ネイティブ Docker ランタイムで、ローカル・コンテナー・オーケストレーションなしで運用されます。 エッジ・クラスターおよびネットワーク/メトロ・エッジは、共有する競合リソース要求に対してワークロードを調整するために Kubernetes を使用して構成されます。 Docker または Kubernetes のいずれかへの明示的な依存を避けるようにコンテナーを実装して、分散エッジコンピューティングの世界の異なる層へのポータビリティーを可能にする必要があります。 
* **構成パラメーターの外部化:** {{site.data.keyword.ieam}} が提供する組み込みサポートを使用して構成変数およびリソース依存関係を外部化することによって、それらの値をコンテナーがデプロイされるノードに固有の値に指定および更新できるようにします。
* **シークレットの保護:** エッジ・サービスは、多くの場合、オンプレミス・ベースまたはクラウド・ベースのサービスとの統合を必要とします。これには認証資格情報が必要です。[シークレット・マネージャー](secrets_details.md)を活用して、機密情報を安全にエッジ・ノードにデプロイしてください。
* **サイズの考慮事項:** 低速なネットワークを経由する場合や、小型のエッジ・デバイスの場合でもサービスをデプロイできるように、サービス・コンテナーはできるだけ小さくする必要があります。 小さなサービス・コンテナーを開発するには以下の技法が役立ちます。

  * 小さなサービスを作成するのに役立つプログラミング言語を使用します。
    * 最適: go、rust、c、sh
    * 適切: c++、python、bash
    * 要検討: nodejs、Java および JVM ベースの言語 (scala など)
  * 小さな Docker イメージを作成するのに役立つ技法を使用します。
    * {{site.data.keyword.linux_notm}} のベース・イメージとして alpine を使用します。
    * alpine ベースのイメージ内のパッケージをインストールするには、ランタイムには不要なパッケージ・キャッシュの保管を避けるため、コマンド `apk --no-cache --update add` を使用します。
    * ファイルが追加されるのと同じ Dockerfile レイヤー (コマンド) でファイルを削除します。 別個の Dockerfile コマンド・ラインを使用してイメージからファイルを削除する場合は、コンテナー・イメージのサイズが大きくなります。 例えば、ファイルをダウンロードし、使用し、その後で削除するための一連のコマンドを `&&` を使用してグループ化して、すべてを 1 つの Dockerfile `RUN` コマンドにすることができます。
    * ランタイム Docker イメージにビルド・ツールを含めないようにします。 ベスト・プラクティスとして、[Docker マルチステージ・ビルド](https://docs.docker.com/develop/develop-images/multistage-build/) を使用してランタイム成果物を作成してください。 次に、必要なランタイム成果物 (実行可能コンポーネントなど) をランタイム Docker イメージに選択的にコピーします。
* **サービスの自己完結性の維持:** サービスはネットワークを経由してエッジ・ノードに送信され、自律的に開始される必要があるため、サービス・コンテナーはサービスが依存しているものすべてを含んでいる必要があります。 これらのアセット (必要なすべての証明書など) をコンテナーにバンドルする必要があります。 サービスが正常に実行されるようにエッジ・ノードに必要なアセットを追加するタスクの実行を管理者に頼ることがないようにしてください。
* **データ・プライバシー:** プライベート・データおよび機密データをネットワークの中で移動するたびに、攻撃および機密漏れに対するそのデータの脆弱性が増します。 エッジコンピューティングは、その主要な利点の 1 つとして、作成された場所でデータを保持する機会を提供します。 コンテナー内でその機会を生かしてデータを保護してください。 そのデータを他のサービスに渡さないのが理想的です。 データをシステム内の他の層または他のサービスにどうしても渡す必要がある場合は、個人識別情報 (PII)、個人医療情報 (PHI)、または個人金融情報 (PFI) を、難読化または匿名化技法を使用するか、サービスの領域内で完全に所有されるキーで暗号化することによって、除去するようにしてください。 
* **自動化に向けた設計および構成:** エッジ・ノード、およびエッジ・ノード上で実行されるサービスは、できるだけ人が介入しない運用に近づける必要があります。 {{site.data.keyword.ieam}} は、サービスのデプロイメントおよび管理を自動化しますが、サービスは、{{site.data.keyword.ieam}} がこれらのプロセスを人手の介入なしで自動化できるような構造になっている必要があります。 以下のガイドラインに従うと、自動化の設計に役立ちます。
  * サービスのユーザー入力変数の数を制限します。 サービス定義内でデフォルト値を指定していない UserInput 変数は、エッジ・ノードごとに値を指定する必要があります。 変数の数を制限するか、可能であれば変数を使用するサービスを避けてください。  
  * サービスが多くの構成可能な設定を必要とする場合、それらの変数を定義するために構成ファイルを使用します。 構成ファイルのデフォルトのバージョンをサービス・コンテナーに含めます。 次に、{{site.data.keyword.ieam}} モデル管理システムを使用して、管理者が独自の構成ファイルを指定し、時間の経過に伴いそれを更新できるようにします。
  * **標準プラットフォーム・サービスの利用:** アプリケーションのニーズの多くは、事前に実装されるプラットフォーム・サービスによって満たすことができます。 アプリケーション内にこれらの機能を初めから作成するのではなく、既に作成されていて、ユーザーに使用可能になっているものを使用することを検討してください。 このようなプラットフォーム・サービスの 1 つのソースには、幅広い機能をカバーしている IBM Cloud Pak があります。それらの機能の多くは、それら自体が、以下に示すようなクラウド・ネイティブなプログラミング・プラクティスを使用して作成されています。
    * **データ管理:** SQL および 非 SQL、ブロック・ストレージおよびオブジェクト・ストレージのデータベース要件、機械学習サービスと AI サービス、およびデータレイクのニーズに対して、IBM Cloud Pak for Data を検討してください。 
    * **セキュリティー:** 暗号化、コードのスキャン、および侵入検出のニーズに対して、IBM CloudPak for Security を検討してください。
    * **アプリケーション:** Web アプリケーション、サーバーレス、およびアプリケーション・フレームワークのニーズに対して、IBM Cloud Pak for Applications を検討してください。
